/* automatically generated by rust-bindgen 0.63.0 */

pub type wchar_t = libc::c_int;
pub type __ino_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __time_t = libc::c_long;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::core::mem::MaybeUninit<tm> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::core::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
pub type zipFile = *mut libc::c_void;
pub type ZPOS64_T = u64;
pub type open_file_func = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut libc::c_void,
        filename: *const libc::c_char,
        mode: libc::c_int,
    ) -> *mut libc::c_void,
>;
pub type open64_file_func = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut libc::c_void,
        filename: *const libc::c_void,
        mode: libc::c_int,
    ) -> *mut libc::c_void,
>;
pub type read_file_func = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut libc::c_void,
        stream: *mut libc::c_void,
        buf: *mut libc::c_void,
        size: libc::c_ulong,
    ) -> libc::c_ulong,
>;
pub type write_file_func = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut libc::c_void,
        stream: *mut libc::c_void,
        buf: *const libc::c_void,
        size: libc::c_ulong,
    ) -> libc::c_ulong,
>;
pub type close_file_func = ::core::option::Option<
    unsafe extern "C" fn(opaque: *mut libc::c_void, stream: *mut libc::c_void) -> libc::c_int,
>;
pub type testerror_file_func = ::core::option::Option<
    unsafe extern "C" fn(opaque: *mut libc::c_void, stream: *mut libc::c_void) -> libc::c_int,
>;
pub type tell_file_func = ::core::option::Option<
    unsafe extern "C" fn(opaque: *mut libc::c_void, stream: *mut libc::c_void) -> libc::c_long,
>;
pub type tell64_file_func = ::core::option::Option<
    unsafe extern "C" fn(opaque: *mut libc::c_void, stream: *mut libc::c_void) -> ZPOS64_T,
>;
pub type seek_file_func = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut libc::c_void,
        stream: *mut libc::c_void,
        offset: libc::c_ulong,
        origin: libc::c_int,
    ) -> libc::c_long,
>;
pub type seek64_file_func = ::core::option::Option<
    unsafe extern "C" fn(
        opaque: *mut libc::c_void,
        stream: *mut libc::c_void,
        offset: ZPOS64_T,
        origin: libc::c_int,
    ) -> libc::c_long,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zlib_filefunc_def_s {
    pub zopen_file: open_file_func,
    pub zread_file: read_file_func,
    pub zwrite_file: write_file_func,
    pub ztell_file: tell_file_func,
    pub zseek_file: seek_file_func,
    pub zclose_file: close_file_func,
    pub zerror_file: testerror_file_func,
    pub opaque: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_zlib_filefunc_def_s() {
    const UNINIT: ::core::mem::MaybeUninit<zlib_filefunc_def_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<zlib_filefunc_def_s>(),
        64usize,
        concat!("Size of: ", stringify!(zlib_filefunc_def_s))
    );
    assert_eq!(
        ::core::mem::align_of::<zlib_filefunc_def_s>(),
        8usize,
        concat!("Alignment of ", stringify!(zlib_filefunc_def_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zopen_file) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zlib_filefunc_def_s),
            "::",
            stringify!(zopen_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zread_file) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zlib_filefunc_def_s),
            "::",
            stringify!(zread_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zwrite_file) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zlib_filefunc_def_s),
            "::",
            stringify!(zwrite_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ztell_file) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(zlib_filefunc_def_s),
            "::",
            stringify!(ztell_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zseek_file) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(zlib_filefunc_def_s),
            "::",
            stringify!(zseek_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zclose_file) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(zlib_filefunc_def_s),
            "::",
            stringify!(zclose_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zerror_file) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(zlib_filefunc_def_s),
            "::",
            stringify!(zerror_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(zlib_filefunc_def_s),
            "::",
            stringify!(opaque)
        )
    );
}
pub type zlib_filefunc_def = zlib_filefunc_def_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zlib_filefunc64_def_s {
    pub zopen64_file: open64_file_func,
    pub zread_file: read_file_func,
    pub zwrite_file: write_file_func,
    pub ztell64_file: tell64_file_func,
    pub zseek64_file: seek64_file_func,
    pub zclose_file: close_file_func,
    pub zerror_file: testerror_file_func,
    pub opaque: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_zlib_filefunc64_def_s() {
    const UNINIT: ::core::mem::MaybeUninit<zlib_filefunc64_def_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<zlib_filefunc64_def_s>(),
        64usize,
        concat!("Size of: ", stringify!(zlib_filefunc64_def_s))
    );
    assert_eq!(
        ::core::mem::align_of::<zlib_filefunc64_def_s>(),
        8usize,
        concat!("Alignment of ", stringify!(zlib_filefunc64_def_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zopen64_file) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zlib_filefunc64_def_s),
            "::",
            stringify!(zopen64_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zread_file) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zlib_filefunc64_def_s),
            "::",
            stringify!(zread_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zwrite_file) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(zlib_filefunc64_def_s),
            "::",
            stringify!(zwrite_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ztell64_file) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(zlib_filefunc64_def_s),
            "::",
            stringify!(ztell64_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zseek64_file) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(zlib_filefunc64_def_s),
            "::",
            stringify!(zseek64_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zclose_file) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(zlib_filefunc64_def_s),
            "::",
            stringify!(zclose_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zerror_file) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(zlib_filefunc64_def_s),
            "::",
            stringify!(zerror_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(zlib_filefunc64_def_s),
            "::",
            stringify!(opaque)
        )
    );
}
pub type zlib_filefunc64_def = zlib_filefunc64_def_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zip_fileinfo {
    pub dosDate: u32,
    pub tmz_date: tm,
    pub internal_fa: u16,
    pub external_fa: u32,
}
#[test]
fn bindgen_test_layout_zip_fileinfo() {
    const UNINIT: ::core::mem::MaybeUninit<zip_fileinfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<zip_fileinfo>(),
        72usize,
        concat!("Size of: ", stringify!(zip_fileinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<zip_fileinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(zip_fileinfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dosDate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(zip_fileinfo),
            "::",
            stringify!(dosDate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tmz_date) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(zip_fileinfo),
            "::",
            stringify!(tmz_date)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).internal_fa) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(zip_fileinfo),
            "::",
            stringify!(internal_fa)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).external_fa) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(zip_fileinfo),
            "::",
            stringify!(external_fa)
        )
    );
}
extern "C" {
    pub fn zipOpen(path: *const libc::c_char, append: libc::c_int) -> zipFile;
}
extern "C" {
    pub fn zipOpen64(path: *const libc::c_void, append: libc::c_int) -> zipFile;
}
extern "C" {
    pub fn zipOpen2(
        path: *const libc::c_char,
        append: libc::c_int,
        globalcomment: *mut *const libc::c_char,
        pzlib_filefunc_def: *mut zlib_filefunc_def,
    ) -> zipFile;
}
extern "C" {
    pub fn zipOpen2_64(
        path: *const libc::c_void,
        append: libc::c_int,
        globalcomment: *mut *const libc::c_char,
        pzlib_filefunc_def: *mut zlib_filefunc64_def,
    ) -> zipFile;
}
extern "C" {
    pub fn zipOpen_MZ(
        stream: *mut libc::c_void,
        append: libc::c_int,
        globalcomment: *mut *const libc::c_char,
    ) -> zipFile;
}
extern "C" {
    pub fn zipGetHandle_MZ(arg1: zipFile) -> *mut libc::c_void;
}
extern "C" {
    pub fn zipGetStream_MZ(file: zipFile) -> *mut libc::c_void;
}
extern "C" {
    pub fn zipOpenNewFileInZip(
        file: zipFile,
        filename: *const libc::c_char,
        zipfi: *const zip_fileinfo,
        extrafield_local: *const libc::c_void,
        size_extrafield_local: u16,
        extrafield_global: *const libc::c_void,
        size_extrafield_global: u16,
        comment: *const libc::c_char,
        compression_method: libc::c_int,
        level: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn zipOpenNewFileInZip_64(
        file: zipFile,
        filename: *const libc::c_char,
        zipfi: *const zip_fileinfo,
        extrafield_local: *const libc::c_void,
        size_extrafield_local: u16,
        extrafield_global: *const libc::c_void,
        size_extrafield_global: u16,
        comment: *const libc::c_char,
        compression_method: libc::c_int,
        level: libc::c_int,
        zip64: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn zipOpenNewFileInZip2(
        file: zipFile,
        filename: *const libc::c_char,
        zipfi: *const zip_fileinfo,
        extrafield_local: *const libc::c_void,
        size_extrafield_local: u16,
        extrafield_global: *const libc::c_void,
        size_extrafield_global: u16,
        comment: *const libc::c_char,
        compression_method: libc::c_int,
        level: libc::c_int,
        raw: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn zipOpenNewFileInZip2_64(
        file: zipFile,
        filename: *const libc::c_char,
        zipfi: *const zip_fileinfo,
        extrafield_local: *const libc::c_void,
        size_extrafield_local: u16,
        extrafield_global: *const libc::c_void,
        size_extrafield_global: u16,
        comment: *const libc::c_char,
        compression_method: libc::c_int,
        level: libc::c_int,
        raw: libc::c_int,
        zip64: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn zipOpenNewFileInZip3(
        file: zipFile,
        filename: *const libc::c_char,
        zipfi: *const zip_fileinfo,
        extrafield_local: *const libc::c_void,
        size_extrafield_local: u16,
        extrafield_global: *const libc::c_void,
        size_extrafield_global: u16,
        comment: *const libc::c_char,
        compression_method: libc::c_int,
        level: libc::c_int,
        raw: libc::c_int,
        windowBits: libc::c_int,
        memLevel: libc::c_int,
        strategy: libc::c_int,
        password: *const libc::c_char,
        crc_for_crypting: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn zipOpenNewFileInZip3_64(
        file: zipFile,
        filename: *const libc::c_char,
        zipfi: *const zip_fileinfo,
        extrafield_local: *const libc::c_void,
        size_extrafield_local: u16,
        extrafield_global: *const libc::c_void,
        size_extrafield_global: u16,
        comment: *const libc::c_char,
        compression_method: libc::c_int,
        level: libc::c_int,
        raw: libc::c_int,
        windowBits: libc::c_int,
        memLevel: libc::c_int,
        strategy: libc::c_int,
        password: *const libc::c_char,
        crc_for_crypting: u32,
        zip64: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn zipOpenNewFileInZip4(
        file: zipFile,
        filename: *const libc::c_char,
        zipfi: *const zip_fileinfo,
        extrafield_local: *const libc::c_void,
        size_extrafield_local: u16,
        extrafield_global: *const libc::c_void,
        size_extrafield_global: u16,
        comment: *const libc::c_char,
        compression_method: libc::c_int,
        level: libc::c_int,
        raw: libc::c_int,
        windowBits: libc::c_int,
        memLevel: libc::c_int,
        strategy: libc::c_int,
        password: *const libc::c_char,
        crc_for_crypting: libc::c_ulong,
        version_madeby: libc::c_ulong,
        flag_base: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn zipOpenNewFileInZip4_64(
        file: zipFile,
        filename: *const libc::c_char,
        zipfi: *const zip_fileinfo,
        extrafield_local: *const libc::c_void,
        size_extrafield_local: u16,
        extrafield_global: *const libc::c_void,
        size_extrafield_global: u16,
        comment: *const libc::c_char,
        compression_method: libc::c_int,
        level: libc::c_int,
        raw: libc::c_int,
        windowBits: libc::c_int,
        memLevel: libc::c_int,
        strategy: libc::c_int,
        password: *const libc::c_char,
        crc_for_crypting: libc::c_ulong,
        version_madeby: libc::c_ulong,
        flag_base: libc::c_ulong,
        zip64: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn zipOpenNewFileInZip5(
        file: zipFile,
        filename: *const libc::c_char,
        zipfi: *const zip_fileinfo,
        extrafield_local: *const libc::c_void,
        size_extrafield_local: u16,
        extrafield_global: *const libc::c_void,
        size_extrafield_global: u16,
        comment: *const libc::c_char,
        compression_method: libc::c_int,
        level: libc::c_int,
        raw: libc::c_int,
        windowBits: libc::c_int,
        memLevel: libc::c_int,
        strategy: libc::c_int,
        password: *const libc::c_char,
        crc_for_crypting: libc::c_ulong,
        version_madeby: libc::c_ulong,
        flag_base: libc::c_ulong,
        zip64: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn zipWriteInFileInZip(file: zipFile, buf: *const libc::c_void, len: u32) -> libc::c_int;
}
extern "C" {
    pub fn zipCloseFileInZipRaw(
        file: zipFile,
        uncompressed_size: libc::c_ulong,
        crc32: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn zipCloseFileInZipRaw64(
        file: zipFile,
        uncompressed_size: u64,
        crc32: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn zipCloseFileInZip(file: zipFile) -> libc::c_int;
}
extern "C" {
    pub fn zipCloseFileInZip64(file: zipFile) -> libc::c_int;
}
extern "C" {
    pub fn zipClose(file: zipFile, global_comment: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn zipClose_64(file: zipFile, global_comment: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn zipClose2_64(
        file: zipFile,
        global_comment: *const libc::c_char,
        version_madeby: u16,
    ) -> libc::c_int;
}
extern "C" {
    pub fn zipClose_MZ(file: zipFile, global_comment: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn zipClose2_MZ(
        file: zipFile,
        global_comment: *const libc::c_char,
        version_madeby: u16,
    ) -> libc::c_int;
}
pub type unzFile = *mut libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unz_global_info64_s {
    pub number_entry: u64,
    pub number_disk_with_CD: u32,
    pub size_comment: u16,
}
#[test]
fn bindgen_test_layout_unz_global_info64_s() {
    const UNINIT: ::core::mem::MaybeUninit<unz_global_info64_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<unz_global_info64_s>(),
        16usize,
        concat!("Size of: ", stringify!(unz_global_info64_s))
    );
    assert_eq!(
        ::core::mem::align_of::<unz_global_info64_s>(),
        8usize,
        concat!("Alignment of ", stringify!(unz_global_info64_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number_entry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_global_info64_s),
            "::",
            stringify!(number_entry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number_disk_with_CD) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_global_info64_s),
            "::",
            stringify!(number_disk_with_CD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size_comment) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_global_info64_s),
            "::",
            stringify!(size_comment)
        )
    );
}
pub type unz_global_info64 = unz_global_info64_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unz_global_info_s {
    pub number_entry: u32,
    pub number_disk_with_CD: u32,
    pub size_comment: u16,
}
#[test]
fn bindgen_test_layout_unz_global_info_s() {
    const UNINIT: ::core::mem::MaybeUninit<unz_global_info_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<unz_global_info_s>(),
        12usize,
        concat!("Size of: ", stringify!(unz_global_info_s))
    );
    assert_eq!(
        ::core::mem::align_of::<unz_global_info_s>(),
        4usize,
        concat!("Alignment of ", stringify!(unz_global_info_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number_entry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_global_info_s),
            "::",
            stringify!(number_entry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number_disk_with_CD) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_global_info_s),
            "::",
            stringify!(number_disk_with_CD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size_comment) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_global_info_s),
            "::",
            stringify!(size_comment)
        )
    );
}
pub type unz_global_info = unz_global_info_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unz_file_info64_s {
    pub version: u16,
    pub version_needed: u16,
    pub flag: u16,
    pub compression_method: u16,
    pub dosDate: u32,
    pub tmu_date: tm,
    pub crc: u32,
    pub compressed_size: u64,
    pub uncompressed_size: u64,
    pub size_filename: u16,
    pub size_file_extra: u16,
    pub size_file_comment: u16,
    pub disk_num_start: u32,
    pub internal_fa: u16,
    pub external_fa: u32,
    pub disk_offset: u64,
    pub size_file_extra_internal: u16,
}
#[test]
fn bindgen_test_layout_unz_file_info64_s() {
    const UNINIT: ::core::mem::MaybeUninit<unz_file_info64_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<unz_file_info64_s>(),
        136usize,
        concat!("Size of: ", stringify!(unz_file_info64_s))
    );
    assert_eq!(
        ::core::mem::align_of::<unz_file_info64_s>(),
        8usize,
        concat!("Alignment of ", stringify!(unz_file_info64_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info64_s),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version_needed) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info64_s),
            "::",
            stringify!(version_needed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info64_s),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).compression_method) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info64_s),
            "::",
            stringify!(compression_method)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dosDate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info64_s),
            "::",
            stringify!(dosDate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tmu_date) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info64_s),
            "::",
            stringify!(tmu_date)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crc) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info64_s),
            "::",
            stringify!(crc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).compressed_size) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info64_s),
            "::",
            stringify!(compressed_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uncompressed_size) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info64_s),
            "::",
            stringify!(uncompressed_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size_filename) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info64_s),
            "::",
            stringify!(size_filename)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size_file_extra) as usize - ptr as usize },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info64_s),
            "::",
            stringify!(size_file_extra)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size_file_comment) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info64_s),
            "::",
            stringify!(size_file_comment)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disk_num_start) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info64_s),
            "::",
            stringify!(disk_num_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).internal_fa) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info64_s),
            "::",
            stringify!(internal_fa)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).external_fa) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info64_s),
            "::",
            stringify!(external_fa)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disk_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info64_s),
            "::",
            stringify!(disk_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size_file_extra_internal) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info64_s),
            "::",
            stringify!(size_file_extra_internal)
        )
    );
}
pub type unz_file_info64 = unz_file_info64_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unz_file_info_s {
    pub version: u16,
    pub version_needed: u16,
    pub flag: u16,
    pub compression_method: u16,
    pub dosDate: u32,
    pub tmu_date: tm,
    pub crc: u32,
    pub compressed_size: u32,
    pub uncompressed_size: u32,
    pub size_filename: u16,
    pub size_file_extra: u16,
    pub size_file_comment: u16,
    pub disk_num_start: u16,
    pub internal_fa: u16,
    pub external_fa: u32,
    pub disk_offset: u64,
}
#[test]
fn bindgen_test_layout_unz_file_info_s() {
    const UNINIT: ::core::mem::MaybeUninit<unz_file_info_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<unz_file_info_s>(),
        112usize,
        concat!("Size of: ", stringify!(unz_file_info_s))
    );
    assert_eq!(
        ::core::mem::align_of::<unz_file_info_s>(),
        8usize,
        concat!("Alignment of ", stringify!(unz_file_info_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info_s),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version_needed) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info_s),
            "::",
            stringify!(version_needed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info_s),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).compression_method) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info_s),
            "::",
            stringify!(compression_method)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dosDate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info_s),
            "::",
            stringify!(dosDate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tmu_date) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info_s),
            "::",
            stringify!(tmu_date)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crc) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info_s),
            "::",
            stringify!(crc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).compressed_size) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info_s),
            "::",
            stringify!(compressed_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uncompressed_size) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info_s),
            "::",
            stringify!(uncompressed_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size_filename) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info_s),
            "::",
            stringify!(size_filename)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size_file_extra) as usize - ptr as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info_s),
            "::",
            stringify!(size_file_extra)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size_file_comment) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info_s),
            "::",
            stringify!(size_file_comment)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disk_num_start) as usize - ptr as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info_s),
            "::",
            stringify!(disk_num_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).internal_fa) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info_s),
            "::",
            stringify!(internal_fa)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).external_fa) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info_s),
            "::",
            stringify!(external_fa)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disk_offset) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_info_s),
            "::",
            stringify!(disk_offset)
        )
    );
}
pub type unz_file_info = unz_file_info_s;
pub type unzFileNameComparer = ::core::option::Option<
    unsafe extern "C" fn(
        file: unzFile,
        filename1: *const libc::c_char,
        filename2: *const libc::c_char,
    ) -> libc::c_int,
>;
extern "C" {
    pub fn unzOpen(path: *const libc::c_char) -> unzFile;
}
extern "C" {
    pub fn unzOpen64(path: *const libc::c_void) -> unzFile;
}
extern "C" {
    pub fn unzOpen2(
        path: *const libc::c_char,
        pzlib_filefunc_def: *mut zlib_filefunc_def,
    ) -> unzFile;
}
extern "C" {
    pub fn unzOpen2_64(
        path: *const libc::c_void,
        pzlib_filefunc_def: *mut zlib_filefunc64_def,
    ) -> unzFile;
}
extern "C" {
    pub fn unzOpen_MZ(stream: *mut libc::c_void) -> unzFile;
}
extern "C" {
    pub fn unzClose(file: unzFile) -> libc::c_int;
}
extern "C" {
    pub fn unzClose_MZ(file: unzFile) -> libc::c_int;
}
extern "C" {
    pub fn unzGetHandle_MZ(file: unzFile) -> *mut libc::c_void;
}
extern "C" {
    pub fn unzGetStream_MZ(file: zipFile) -> *mut libc::c_void;
}
extern "C" {
    pub fn unzGetGlobalInfo(file: unzFile, pglobal_info32: *mut unz_global_info) -> libc::c_int;
}
extern "C" {
    pub fn unzGetGlobalInfo64(file: unzFile, pglobal_info: *mut unz_global_info64) -> libc::c_int;
}
extern "C" {
    pub fn unzGetGlobalComment(
        file: unzFile,
        comment: *mut libc::c_char,
        comment_size: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn unzOpenCurrentFile(file: unzFile) -> libc::c_int;
}
extern "C" {
    pub fn unzOpenCurrentFilePassword(file: unzFile, password: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn unzOpenCurrentFile2(
        file: unzFile,
        method: *mut libc::c_int,
        level: *mut libc::c_int,
        raw: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn unzOpenCurrentFile3(
        file: unzFile,
        method: *mut libc::c_int,
        level: *mut libc::c_int,
        raw: libc::c_int,
        password: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn unzReadCurrentFile(file: unzFile, buf: *mut libc::c_void, len: u32) -> libc::c_int;
}
extern "C" {
    pub fn unzCloseCurrentFile(file: unzFile) -> libc::c_int;
}
extern "C" {
    pub fn unzGetCurrentFileInfo(
        file: unzFile,
        pfile_info: *mut unz_file_info,
        filename: *mut libc::c_char,
        filename_size: libc::c_ulong,
        extrafield: *mut libc::c_void,
        extrafield_size: libc::c_ulong,
        comment: *mut libc::c_char,
        comment_size: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn unzGetCurrentFileInfo64(
        file: unzFile,
        pfile_info: *mut unz_file_info64,
        filename: *mut libc::c_char,
        filename_size: libc::c_ulong,
        extrafield: *mut libc::c_void,
        extrafield_size: libc::c_ulong,
        comment: *mut libc::c_char,
        comment_size: libc::c_ulong,
    ) -> libc::c_int;
}
extern "C" {
    pub fn unzGoToFirstFile(file: unzFile) -> libc::c_int;
}
extern "C" {
    pub fn unzGoToNextFile(file: unzFile) -> libc::c_int;
}
extern "C" {
    pub fn unzLocateFile(
        file: unzFile,
        filename: *const libc::c_char,
        filename_compare_func: unzFileNameComparer,
    ) -> libc::c_int;
}
extern "C" {
    pub fn unzGetLocalExtrafield(
        file: unzFile,
        buf: *mut libc::c_void,
        len: libc::c_uint,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unz_file_pos_s {
    pub pos_in_zip_directory: u32,
    pub num_of_file: u32,
}
#[test]
fn bindgen_test_layout_unz_file_pos_s() {
    const UNINIT: ::core::mem::MaybeUninit<unz_file_pos_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<unz_file_pos_s>(),
        8usize,
        concat!("Size of: ", stringify!(unz_file_pos_s))
    );
    assert_eq!(
        ::core::mem::align_of::<unz_file_pos_s>(),
        4usize,
        concat!("Alignment of ", stringify!(unz_file_pos_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pos_in_zip_directory) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_pos_s),
            "::",
            stringify!(pos_in_zip_directory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_of_file) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(unz_file_pos_s),
            "::",
            stringify!(num_of_file)
        )
    );
}
pub type unz_file_pos = unz_file_pos_s;
extern "C" {
    pub fn unzGetFilePos(file: unzFile, file_pos: *mut unz_file_pos) -> libc::c_int;
}
extern "C" {
    pub fn unzGoToFilePos(file: unzFile, file_pos: *mut unz_file_pos) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unz64_file_pos_s {
    pub pos_in_zip_directory: i64,
    pub num_of_file: u64,
}
#[test]
fn bindgen_test_layout_unz64_file_pos_s() {
    const UNINIT: ::core::mem::MaybeUninit<unz64_file_pos_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<unz64_file_pos_s>(),
        16usize,
        concat!("Size of: ", stringify!(unz64_file_pos_s))
    );
    assert_eq!(
        ::core::mem::align_of::<unz64_file_pos_s>(),
        8usize,
        concat!("Alignment of ", stringify!(unz64_file_pos_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pos_in_zip_directory) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unz64_file_pos_s),
            "::",
            stringify!(pos_in_zip_directory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_of_file) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(unz64_file_pos_s),
            "::",
            stringify!(num_of_file)
        )
    );
}
pub type unz64_file_pos = unz64_file_pos_s;
extern "C" {
    pub fn unzGetFilePos64(file: unzFile, file_pos: *mut unz64_file_pos) -> libc::c_int;
}
extern "C" {
    pub fn unzGoToFilePos64(file: unzFile, file_pos: *const unz64_file_pos) -> libc::c_int;
}
extern "C" {
    pub fn unzGetOffset64(file: unzFile) -> i64;
}
extern "C" {
    pub fn unzGetOffset(file: unzFile) -> libc::c_ulong;
}
extern "C" {
    pub fn unzSetOffset64(file: unzFile, pos: i64) -> libc::c_int;
}
extern "C" {
    pub fn unzSetOffset(file: unzFile, pos: libc::c_ulong) -> libc::c_int;
}
extern "C" {
    pub fn unztell(file: unzFile) -> i32;
}
extern "C" {
    pub fn unzTell(file: unzFile) -> i32;
}
extern "C" {
    pub fn unztell64(file: unzFile) -> u64;
}
extern "C" {
    pub fn unzTell64(file: unzFile) -> u64;
}
extern "C" {
    pub fn unzSeek(file: unzFile, offset: i32, origin: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn unzSeek64(file: unzFile, offset: i64, origin: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn unzEndOfFile(file: unzFile) -> libc::c_int;
}
extern "C" {
    pub fn unzeof(file: unzFile) -> libc::c_int;
}
extern "C" {
    pub fn unzGetStream(file: unzFile) -> *mut libc::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: libc::c_ushort,
    pub d_type: libc::c_uchar,
    pub d_name: [libc::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_dirent() {
    const UNINIT: ::core::mem::MaybeUninit<dirent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<dirent>(),
        280usize,
        concat!("Size of: ", stringify!(dirent))
    );
    assert_eq!(
        ::core::mem::align_of::<dirent>(),
        8usize,
        concat!("Alignment of ", stringify!(dirent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_ino) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_ino)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_off) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_off)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_reclen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_reclen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_type) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_name) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
extern "C" {
    pub fn mz_path_combine(
        path: *mut libc::c_char,
        join: *const libc::c_char,
        max_path: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_path_append_slash(path: *mut libc::c_char, max_path: i32, slash: libc::c_char)
        -> i32;
}
extern "C" {
    pub fn mz_path_remove_slash(path: *mut libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_path_has_slash(path: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_path_convert_slashes(path: *mut libc::c_char, slash: libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_path_compare_wc(
        path: *const libc::c_char,
        wildcard: *const libc::c_char,
        ignore_case: u8,
    ) -> i32;
}
extern "C" {
    pub fn mz_path_resolve(
        path: *const libc::c_char,
        target: *mut libc::c_char,
        max_target: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_path_remove_filename(path: *mut libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_path_remove_extension(path: *mut libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_path_get_filename(
        path: *const libc::c_char,
        filename: *mut *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_dir_make(path: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_file_get_crc(path: *const libc::c_char, result_crc: *mut u32) -> i32;
}
extern "C" {
    pub fn mz_os_unicode_string_create(string: *const libc::c_char, encoding: i32) -> *mut wchar_t;
}
extern "C" {
    pub fn mz_os_unicode_string_delete(string: *mut *mut wchar_t);
}
extern "C" {
    pub fn mz_os_utf8_string_create(string: *const libc::c_char, encoding: i32) -> *mut u8;
}
extern "C" {
    pub fn mz_os_utf8_string_delete(string: *mut *mut u8);
}
extern "C" {
    pub fn mz_os_rand(buf: *mut u8, size: i32) -> i32;
}
extern "C" {
    pub fn mz_os_rename(source_path: *const libc::c_char, target_path: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_os_unlink(path: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_os_file_exists(path: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_os_get_file_size(path: *const libc::c_char) -> i64;
}
extern "C" {
    pub fn mz_os_get_file_date(
        path: *const libc::c_char,
        modified_date: *mut time_t,
        accessed_date: *mut time_t,
        creation_date: *mut time_t,
    ) -> i32;
}
extern "C" {
    pub fn mz_os_set_file_date(
        path: *const libc::c_char,
        modified_date: time_t,
        accessed_date: time_t,
        creation_date: time_t,
    ) -> i32;
}
extern "C" {
    pub fn mz_os_get_file_attribs(path: *const libc::c_char, attributes: *mut u32) -> i32;
}
extern "C" {
    pub fn mz_os_set_file_attribs(path: *const libc::c_char, attributes: u32) -> i32;
}
extern "C" {
    pub fn mz_os_make_dir(path: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_os_open_dir(path: *const libc::c_char) -> *mut DIR;
}
extern "C" {
    pub fn mz_os_read_dir(dir: *mut DIR) -> *mut dirent;
}
extern "C" {
    pub fn mz_os_close_dir(dir: *mut DIR) -> i32;
}
extern "C" {
    pub fn mz_os_is_dir(path: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_os_is_symlink(path: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_os_make_symlink(path: *const libc::c_char, target_path: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_os_read_symlink(
        path: *const libc::c_char,
        target_path: *mut libc::c_char,
        max_target_path: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_os_ms_time() -> u64;
}
pub type mz_stream_open_cb = ::core::option::Option<
    unsafe extern "C" fn(stream: *mut libc::c_void, path: *const libc::c_char, mode: i32) -> i32,
>;
pub type mz_stream_is_open_cb =
    ::core::option::Option<unsafe extern "C" fn(stream: *mut libc::c_void) -> i32>;
pub type mz_stream_read_cb = ::core::option::Option<
    unsafe extern "C" fn(stream: *mut libc::c_void, buf: *mut libc::c_void, size: i32) -> i32,
>;
pub type mz_stream_write_cb = ::core::option::Option<
    unsafe extern "C" fn(stream: *mut libc::c_void, buf: *const libc::c_void, size: i32) -> i32,
>;
pub type mz_stream_tell_cb =
    ::core::option::Option<unsafe extern "C" fn(stream: *mut libc::c_void) -> i64>;
pub type mz_stream_seek_cb = ::core::option::Option<
    unsafe extern "C" fn(stream: *mut libc::c_void, offset: i64, origin: i32) -> i32,
>;
pub type mz_stream_close_cb =
    ::core::option::Option<unsafe extern "C" fn(stream: *mut libc::c_void) -> i32>;
pub type mz_stream_error_cb =
    ::core::option::Option<unsafe extern "C" fn(stream: *mut libc::c_void) -> i32>;
pub type mz_stream_create_cb = ::core::option::Option<
    unsafe extern "C" fn(stream: *mut *mut libc::c_void) -> *mut libc::c_void,
>;
pub type mz_stream_destroy_cb =
    ::core::option::Option<unsafe extern "C" fn(stream: *mut *mut libc::c_void)>;
pub type mz_stream_get_prop_int64_cb = ::core::option::Option<
    unsafe extern "C" fn(stream: *mut libc::c_void, prop: i32, value: *mut i64) -> i32,
>;
pub type mz_stream_set_prop_int64_cb = ::core::option::Option<
    unsafe extern "C" fn(stream: *mut libc::c_void, prop: i32, value: i64) -> i32,
>;
pub type mz_stream_find_cb = ::core::option::Option<
    unsafe extern "C" fn(
        stream: *mut libc::c_void,
        find: *const libc::c_void,
        find_size: i32,
        max_seek: i64,
        position: *mut i64,
    ) -> i32,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mz_stream_vtbl_s {
    pub open: mz_stream_open_cb,
    pub is_open: mz_stream_is_open_cb,
    pub read: mz_stream_read_cb,
    pub write: mz_stream_write_cb,
    pub tell: mz_stream_tell_cb,
    pub seek: mz_stream_seek_cb,
    pub close: mz_stream_close_cb,
    pub error: mz_stream_error_cb,
    pub create: mz_stream_create_cb,
    pub destroy: mz_stream_destroy_cb,
    pub get_prop_int64: mz_stream_get_prop_int64_cb,
    pub set_prop_int64: mz_stream_set_prop_int64_cb,
}
#[test]
fn bindgen_test_layout_mz_stream_vtbl_s() {
    const UNINIT: ::core::mem::MaybeUninit<mz_stream_vtbl_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mz_stream_vtbl_s>(),
        96usize,
        concat!("Size of: ", stringify!(mz_stream_vtbl_s))
    );
    assert_eq!(
        ::core::mem::align_of::<mz_stream_vtbl_s>(),
        8usize,
        concat!("Alignment of ", stringify!(mz_stream_vtbl_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_open) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(is_open)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tell) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).create) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_prop_int64) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(get_prop_int64)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_prop_int64) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(set_prop_int64)
        )
    );
}
pub type mz_stream_vtbl = mz_stream_vtbl_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mz_stream_s {
    pub vtbl: *mut mz_stream_vtbl,
    pub base: *mut mz_stream_s,
}
#[test]
fn bindgen_test_layout_mz_stream_s() {
    const UNINIT: ::core::mem::MaybeUninit<mz_stream_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mz_stream_s>(),
        16usize,
        concat!("Size of: ", stringify!(mz_stream_s))
    );
    assert_eq!(
        ::core::mem::align_of::<mz_stream_s>(),
        8usize,
        concat!("Alignment of ", stringify!(mz_stream_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vtbl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_s),
            "::",
            stringify!(vtbl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_s),
            "::",
            stringify!(base)
        )
    );
}
pub type mz_stream = mz_stream_s;
extern "C" {
    pub fn mz_stream_open(stream: *mut libc::c_void, path: *const libc::c_char, mode: i32) -> i32;
}
extern "C" {
    pub fn mz_stream_is_open(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_read(stream: *mut libc::c_void, buf: *mut libc::c_void, size: i32) -> i32;
}
extern "C" {
    pub fn mz_stream_read_uint8(stream: *mut libc::c_void, value: *mut u8) -> i32;
}
extern "C" {
    pub fn mz_stream_read_uint16(stream: *mut libc::c_void, value: *mut u16) -> i32;
}
extern "C" {
    pub fn mz_stream_read_uint32(stream: *mut libc::c_void, value: *mut u32) -> i32;
}
extern "C" {
    pub fn mz_stream_read_int64(stream: *mut libc::c_void, value: *mut i64) -> i32;
}
extern "C" {
    pub fn mz_stream_read_uint64(stream: *mut libc::c_void, value: *mut u64) -> i32;
}
extern "C" {
    pub fn mz_stream_write(stream: *mut libc::c_void, buf: *const libc::c_void, size: i32) -> i32;
}
extern "C" {
    pub fn mz_stream_write_uint8(stream: *mut libc::c_void, value: u8) -> i32;
}
extern "C" {
    pub fn mz_stream_write_uint16(stream: *mut libc::c_void, value: u16) -> i32;
}
extern "C" {
    pub fn mz_stream_write_uint32(stream: *mut libc::c_void, value: u32) -> i32;
}
extern "C" {
    pub fn mz_stream_write_int64(stream: *mut libc::c_void, value: i64) -> i32;
}
extern "C" {
    pub fn mz_stream_write_uint64(stream: *mut libc::c_void, value: u64) -> i32;
}
extern "C" {
    pub fn mz_stream_copy(target: *mut libc::c_void, source: *mut libc::c_void, len: i32) -> i32;
}
extern "C" {
    pub fn mz_stream_copy_to_end(target: *mut libc::c_void, source: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_copy_stream(
        target: *mut libc::c_void,
        write_cb: mz_stream_write_cb,
        source: *mut libc::c_void,
        read_cb: mz_stream_read_cb,
        len: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_copy_stream_to_end(
        target: *mut libc::c_void,
        write_cb: mz_stream_write_cb,
        source: *mut libc::c_void,
        read_cb: mz_stream_read_cb,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_tell(stream: *mut libc::c_void) -> i64;
}
extern "C" {
    pub fn mz_stream_seek(stream: *mut libc::c_void, offset: i64, origin: i32) -> i32;
}
extern "C" {
    pub fn mz_stream_find(
        stream: *mut libc::c_void,
        find: *const libc::c_void,
        find_size: i32,
        max_seek: i64,
        position: *mut i64,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_find_reverse(
        stream: *mut libc::c_void,
        find: *const libc::c_void,
        find_size: i32,
        max_seek: i64,
        position: *mut i64,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_close(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_error(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_set_base(stream: *mut libc::c_void, base: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_get_interface(stream: *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    pub fn mz_stream_get_prop_int64(stream: *mut libc::c_void, prop: i32, value: *mut i64) -> i32;
}
extern "C" {
    pub fn mz_stream_set_prop_int64(stream: *mut libc::c_void, prop: i32, value: i64) -> i32;
}
extern "C" {
    pub fn mz_stream_create(
        stream: *mut *mut libc::c_void,
        vtbl: *mut mz_stream_vtbl,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mz_stream_delete(stream: *mut *mut libc::c_void);
}
extern "C" {
    pub fn mz_stream_raw_open(
        stream: *mut libc::c_void,
        filename: *const libc::c_char,
        mode: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_raw_is_open(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_raw_read(stream: *mut libc::c_void, buf: *mut libc::c_void, size: i32) -> i32;
}
extern "C" {
    pub fn mz_stream_raw_write(
        stream: *mut libc::c_void,
        buf: *const libc::c_void,
        size: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_raw_tell(stream: *mut libc::c_void) -> i64;
}
extern "C" {
    pub fn mz_stream_raw_seek(stream: *mut libc::c_void, offset: i64, origin: i32) -> i32;
}
extern "C" {
    pub fn mz_stream_raw_close(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_raw_error(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_raw_get_prop_int64(
        stream: *mut libc::c_void,
        prop: i32,
        value: *mut i64,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_raw_set_prop_int64(stream: *mut libc::c_void, prop: i32, value: i64) -> i32;
}
extern "C" {
    pub fn mz_stream_raw_create(stream: *mut *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    pub fn mz_stream_raw_delete(stream: *mut *mut libc::c_void);
}
extern "C" {
    pub fn mz_stream_buffered_open(
        stream: *mut libc::c_void,
        path: *const libc::c_char,
        mode: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_buffered_is_open(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_buffered_read(
        stream: *mut libc::c_void,
        buf: *mut libc::c_void,
        size: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_buffered_write(
        stream: *mut libc::c_void,
        buf: *const libc::c_void,
        size: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_buffered_tell(stream: *mut libc::c_void) -> i64;
}
extern "C" {
    pub fn mz_stream_buffered_seek(stream: *mut libc::c_void, offset: i64, origin: i32) -> i32;
}
extern "C" {
    pub fn mz_stream_buffered_close(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_buffered_error(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_buffered_create(stream: *mut *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    pub fn mz_stream_buffered_delete(stream: *mut *mut libc::c_void);
}
extern "C" {
    pub fn mz_stream_buffered_get_interface() -> *mut libc::c_void;
}
extern "C" {
    pub fn mz_stream_split_open(
        stream: *mut libc::c_void,
        filename: *const libc::c_char,
        mode: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_split_is_open(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_split_read(
        stream: *mut libc::c_void,
        buf: *mut libc::c_void,
        size: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_split_write(
        stream: *mut libc::c_void,
        buf: *const libc::c_void,
        size: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_split_tell(stream: *mut libc::c_void) -> i64;
}
extern "C" {
    pub fn mz_stream_split_seek(stream: *mut libc::c_void, offset: i64, origin: i32) -> i32;
}
extern "C" {
    pub fn mz_stream_split_close(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_split_error(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_split_get_prop_int64(
        stream: *mut libc::c_void,
        prop: i32,
        value: *mut i64,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_split_set_prop_int64(stream: *mut libc::c_void, prop: i32, value: i64) -> i32;
}
extern "C" {
    pub fn mz_stream_split_create(stream: *mut *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    pub fn mz_stream_split_delete(stream: *mut *mut libc::c_void);
}
extern "C" {
    pub fn mz_stream_split_get_interface() -> *mut libc::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mz_zip_file_s {
    pub version_madeby: u16,
    pub version_needed: u16,
    pub flag: u16,
    pub compression_method: u16,
    pub modified_date: time_t,
    pub accessed_date: time_t,
    pub creation_date: time_t,
    pub crc: u32,
    pub compressed_size: i64,
    pub uncompressed_size: i64,
    pub filename_size: u16,
    pub extrafield_size: u16,
    pub comment_size: u16,
    pub disk_number: u32,
    pub disk_offset: i64,
    pub internal_fa: u16,
    pub external_fa: u32,
    pub filename: *const libc::c_char,
    pub extrafield: *const u8,
    pub comment: *const libc::c_char,
    pub linkname: *const libc::c_char,
    pub zip64: u16,
    pub aes_version: u16,
    pub aes_encryption_mode: u8,
    pub pk_verify: u16,
}
#[test]
fn bindgen_test_layout_mz_zip_file_s() {
    const UNINIT: ::core::mem::MaybeUninit<mz_zip_file_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mz_zip_file_s>(),
        128usize,
        concat!("Size of: ", stringify!(mz_zip_file_s))
    );
    assert_eq!(
        ::core::mem::align_of::<mz_zip_file_s>(),
        8usize,
        concat!("Alignment of ", stringify!(mz_zip_file_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version_madeby) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(version_madeby)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version_needed) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(version_needed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).compression_method) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(compression_method)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).modified_date) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(modified_date)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accessed_date) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(accessed_date)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).creation_date) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(creation_date)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(crc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).compressed_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(compressed_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uncompressed_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(uncompressed_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filename_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(filename_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extrafield_size) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(extrafield_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).comment_size) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(comment_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disk_number) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(disk_number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).disk_offset) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(disk_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).internal_fa) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(internal_fa)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).external_fa) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(external_fa)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extrafield) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(extrafield)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).comment) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(comment)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).linkname) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(linkname)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).zip64) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(zip64)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aes_version) as usize - ptr as usize },
        122usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(aes_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).aes_encryption_mode) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(aes_encryption_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pk_verify) as usize - ptr as usize },
        126usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(pk_verify)
        )
    );
}
pub type mz_zip_file = mz_zip_file_s;
pub type mz_zip_entry = mz_zip_file_s;
pub type mz_zip_locate_entry_cb = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        file_info: *mut mz_zip_file,
    ) -> i32,
>;
extern "C" {
    pub fn mz_zip_create(handle: *mut *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    pub fn mz_zip_delete(handle: *mut *mut libc::c_void);
}
extern "C" {
    pub fn mz_zip_open(handle: *mut libc::c_void, stream: *mut libc::c_void, mode: i32) -> i32;
}
extern "C" {
    pub fn mz_zip_close(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_get_comment(handle: *mut libc::c_void, comment: *mut *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_zip_set_comment(handle: *mut libc::c_void, comment: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_zip_get_version_madeby(handle: *mut libc::c_void, version_madeby: *mut u16) -> i32;
}
extern "C" {
    pub fn mz_zip_set_version_madeby(handle: *mut libc::c_void, version_madeby: u16) -> i32;
}
extern "C" {
    pub fn mz_zip_set_recover(handle: *mut libc::c_void, recover: u8) -> i32;
}
extern "C" {
    pub fn mz_zip_set_data_descriptor(handle: *mut libc::c_void, data_descriptor: u8) -> i32;
}
extern "C" {
    pub fn mz_zip_get_stream(handle: *mut libc::c_void, stream: *mut *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_set_cd_stream(
        handle: *mut libc::c_void,
        cd_start_pos: i64,
        cd_stream: *mut libc::c_void,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_get_cd_mem_stream(
        handle: *mut libc::c_void,
        cd_mem_stream: *mut *mut libc::c_void,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_set_number_entry(handle: *mut libc::c_void, number_entry: u64) -> i32;
}
extern "C" {
    pub fn mz_zip_get_number_entry(handle: *mut libc::c_void, number_entry: *mut u64) -> i32;
}
extern "C" {
    pub fn mz_zip_set_disk_number_with_cd(
        handle: *mut libc::c_void,
        disk_number_with_cd: u32,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_get_disk_number_with_cd(
        handle: *mut libc::c_void,
        disk_number_with_cd: *mut u32,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_is_open(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_read_open(
        handle: *mut libc::c_void,
        raw: u8,
        password: *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_read(handle: *mut libc::c_void, buf: *mut libc::c_void, len: i32) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_read_close(
        handle: *mut libc::c_void,
        crc32: *mut u32,
        compressed_size: *mut i64,
        uncompressed_size: *mut i64,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_write_open(
        handle: *mut libc::c_void,
        file_info: *const mz_zip_file,
        compress_level: i16,
        raw: u8,
        password: *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_write(handle: *mut libc::c_void, buf: *const libc::c_void, len: i32)
        -> i32;
}
extern "C" {
    pub fn mz_zip_entry_write_close(
        handle: *mut libc::c_void,
        crc32: u32,
        compressed_size: i64,
        uncompressed_size: i64,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_seek_local_header(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_close_raw(
        handle: *mut libc::c_void,
        uncompressed_size: i64,
        crc32: u32,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_close(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_is_dir(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_is_symlink(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_get_info(
        handle: *mut libc::c_void,
        file_info: *mut *mut mz_zip_file,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_get_local_info(
        handle: *mut libc::c_void,
        local_file_info: *mut *mut mz_zip_file,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_set_extrafield(
        handle: *mut libc::c_void,
        extrafield: *const u8,
        extrafield_size: u16,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_get_entry(handle: *mut libc::c_void) -> i64;
}
extern "C" {
    pub fn mz_zip_goto_entry(handle: *mut libc::c_void, cd_pos: i64) -> i32;
}
extern "C" {
    pub fn mz_zip_goto_first_entry(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_goto_next_entry(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_locate_entry(
        handle: *mut libc::c_void,
        filename: *const libc::c_char,
        ignore_case: u8,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_locate_first_entry(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        cb: mz_zip_locate_entry_cb,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_locate_next_entry(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        cb: mz_zip_locate_entry_cb,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_attrib_is_dir(attrib: u32, version_madeby: i32) -> i32;
}
extern "C" {
    pub fn mz_zip_attrib_is_symlink(attrib: u32, version_madeby: i32) -> i32;
}
extern "C" {
    pub fn mz_zip_attrib_convert(
        src_sys: u8,
        src_attrib: u32,
        target_sys: u8,
        target_attrib: *mut u32,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_attrib_posix_to_win32(posix_attrib: u32, win32_attrib: *mut u32) -> i32;
}
extern "C" {
    pub fn mz_zip_attrib_win32_to_posix(win32_attrib: u32, posix_attrib: *mut u32) -> i32;
}
extern "C" {
    pub fn mz_zip_extrafield_find(
        stream: *mut libc::c_void,
        type_: u16,
        max_seek: i32,
        length: *mut u16,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_extrafield_contains(
        extrafield: *const u8,
        extrafield_size: i32,
        type_: u16,
        length: *mut u16,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_extrafield_read(
        stream: *mut libc::c_void,
        type_: *mut u16,
        length: *mut u16,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_extrafield_write(stream: *mut libc::c_void, type_: u16, length: u16) -> i32;
}
extern "C" {
    pub fn mz_zip_dosdate_to_tm(dos_date: u64, ptm: *mut tm) -> i32;
}
extern "C" {
    pub fn mz_zip_dosdate_to_time_t(dos_date: u64) -> time_t;
}
extern "C" {
    pub fn mz_zip_time_t_to_tm(unix_time: time_t, ptm: *mut tm) -> i32;
}
extern "C" {
    pub fn mz_zip_time_t_to_dos_date(unix_time: time_t) -> u32;
}
extern "C" {
    pub fn mz_zip_tm_to_dosdate(ptm: *const tm) -> u32;
}
extern "C" {
    pub fn mz_zip_ntfs_to_unix_time(ntfs_time: u64, unix_time: *mut time_t) -> i32;
}
extern "C" {
    pub fn mz_zip_unix_to_ntfs_time(unix_time: time_t, ntfs_time: *mut u64) -> i32;
}
extern "C" {
    pub fn mz_zip_path_compare(
        path1: *const libc::c_char,
        path2: *const libc::c_char,
        ignore_case: u8,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_get_compression_method_string(compression_method: i32) -> *const libc::c_char;
}
pub type mz_zip_reader_overwrite_cb = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        file_info: *mut mz_zip_file,
        path: *const libc::c_char,
    ) -> i32,
>;
pub type mz_zip_reader_password_cb = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        file_info: *mut mz_zip_file,
        password: *mut libc::c_char,
        max_password: i32,
    ) -> i32,
>;
pub type mz_zip_reader_progress_cb = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        file_info: *mut mz_zip_file,
        position: i64,
    ) -> i32,
>;
pub type mz_zip_reader_entry_cb = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        file_info: *mut mz_zip_file,
        path: *const libc::c_char,
    ) -> i32,
>;
extern "C" {
    pub fn mz_zip_reader_is_open(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_open(handle: *mut libc::c_void, stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_open_file(handle: *mut libc::c_void, path: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_open_file_in_memory(
        handle: *mut libc::c_void,
        path: *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_open_buffer(
        handle: *mut libc::c_void,
        buf: *mut u8,
        len: i32,
        copy: u8,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_close(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_unzip_cd(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_goto_first_entry(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_goto_next_entry(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_locate_entry(
        handle: *mut libc::c_void,
        filename: *const libc::c_char,
        ignore_case: u8,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_open(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_close(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_read(
        handle: *mut libc::c_void,
        buf: *mut libc::c_void,
        len: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_has_sign(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_sign_verify(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_get_hash(
        handle: *mut libc::c_void,
        algorithm: u16,
        digest: *mut u8,
        digest_size: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_get_first_hash(
        handle: *mut libc::c_void,
        algorithm: *mut u16,
        digest_size: *mut u16,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_get_info(
        handle: *mut libc::c_void,
        file_info: *mut *mut mz_zip_file,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_is_dir(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_save(
        handle: *mut libc::c_void,
        stream: *mut libc::c_void,
        write_cb: mz_stream_write_cb,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_save_process(
        handle: *mut libc::c_void,
        stream: *mut libc::c_void,
        write_cb: mz_stream_write_cb,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_save_file(
        handle: *mut libc::c_void,
        path: *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_save_buffer(
        handle: *mut libc::c_void,
        buf: *mut libc::c_void,
        len: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_save_buffer_length(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_save_all(
        handle: *mut libc::c_void,
        destination_dir: *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_set_pattern(
        handle: *mut libc::c_void,
        pattern: *const libc::c_char,
        ignore_case: u8,
    );
}
extern "C" {
    pub fn mz_zip_reader_set_password(handle: *mut libc::c_void, password: *const libc::c_char);
}
extern "C" {
    pub fn mz_zip_reader_set_raw(handle: *mut libc::c_void, raw: u8);
}
extern "C" {
    pub fn mz_zip_reader_get_raw(handle: *mut libc::c_void, raw: *mut u8) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_get_zip_cd(handle: *mut libc::c_void, zip_cd: *mut u8) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_get_comment(
        handle: *mut libc::c_void,
        comment: *mut *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_set_recover(handle: *mut libc::c_void, recover: u8) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_set_encoding(handle: *mut libc::c_void, encoding: i32);
}
extern "C" {
    pub fn mz_zip_reader_set_sign_required(handle: *mut libc::c_void, sign_required: u8);
}
extern "C" {
    pub fn mz_zip_reader_set_overwrite_cb(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        cb: mz_zip_reader_overwrite_cb,
    );
}
extern "C" {
    pub fn mz_zip_reader_set_password_cb(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        cb: mz_zip_reader_password_cb,
    );
}
extern "C" {
    pub fn mz_zip_reader_set_progress_cb(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        cb: mz_zip_reader_progress_cb,
    );
}
extern "C" {
    pub fn mz_zip_reader_set_progress_interval(handle: *mut libc::c_void, milliseconds: u32);
}
extern "C" {
    pub fn mz_zip_reader_set_entry_cb(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        cb: mz_zip_reader_entry_cb,
    );
}
extern "C" {
    pub fn mz_zip_reader_get_zip_handle(
        handle: *mut libc::c_void,
        zip_handle: *mut *mut libc::c_void,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_create(handle: *mut *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    pub fn mz_zip_reader_delete(handle: *mut *mut libc::c_void);
}
pub type mz_zip_writer_overwrite_cb = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        path: *const libc::c_char,
    ) -> i32,
>;
pub type mz_zip_writer_password_cb = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        file_info: *mut mz_zip_file,
        password: *mut libc::c_char,
        max_password: i32,
    ) -> i32,
>;
pub type mz_zip_writer_progress_cb = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        file_info: *mut mz_zip_file,
        position: i64,
    ) -> i32,
>;
pub type mz_zip_writer_entry_cb = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        file_info: *mut mz_zip_file,
    ) -> i32,
>;
extern "C" {
    pub fn mz_zip_writer_is_open(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_open(
        handle: *mut libc::c_void,
        stream: *mut libc::c_void,
        append: u8,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_open_file(
        handle: *mut libc::c_void,
        path: *const libc::c_char,
        disk_size: i64,
        append: u8,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_open_file_in_memory(
        handle: *mut libc::c_void,
        path: *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_close(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_entry_open(handle: *mut libc::c_void, file_info: *mut mz_zip_file) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_entry_close(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_entry_write(
        handle: *mut libc::c_void,
        buf: *const libc::c_void,
        len: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_add(
        handle: *mut libc::c_void,
        stream: *mut libc::c_void,
        read_cb: mz_stream_read_cb,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_add_process(
        handle: *mut libc::c_void,
        stream: *mut libc::c_void,
        read_cb: mz_stream_read_cb,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_add_info(
        handle: *mut libc::c_void,
        stream: *mut libc::c_void,
        read_cb: mz_stream_read_cb,
        file_info: *mut mz_zip_file,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_add_buffer(
        handle: *mut libc::c_void,
        buf: *mut libc::c_void,
        len: i32,
        file_info: *mut mz_zip_file,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_add_file(
        handle: *mut libc::c_void,
        path: *const libc::c_char,
        filename_in_zip: *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_add_path(
        handle: *mut libc::c_void,
        path: *const libc::c_char,
        root_path: *const libc::c_char,
        include_path: u8,
        recursive: u8,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_copy_from_reader(
        handle: *mut libc::c_void,
        reader: *mut libc::c_void,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_set_password(handle: *mut libc::c_void, password: *const libc::c_char);
}
extern "C" {
    pub fn mz_zip_writer_set_comment(handle: *mut libc::c_void, comment: *const libc::c_char);
}
extern "C" {
    pub fn mz_zip_writer_set_raw(handle: *mut libc::c_void, raw: u8);
}
extern "C" {
    pub fn mz_zip_writer_get_raw(handle: *mut libc::c_void, raw: *mut u8) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_set_aes(handle: *mut libc::c_void, aes: u8);
}
extern "C" {
    pub fn mz_zip_writer_set_compress_method(handle: *mut libc::c_void, compress_method: u16);
}
extern "C" {
    pub fn mz_zip_writer_set_compress_level(handle: *mut libc::c_void, compress_level: i16);
}
extern "C" {
    pub fn mz_zip_writer_set_follow_links(handle: *mut libc::c_void, follow_links: u8);
}
extern "C" {
    pub fn mz_zip_writer_set_store_links(handle: *mut libc::c_void, store_links: u8);
}
extern "C" {
    pub fn mz_zip_writer_set_zip_cd(handle: *mut libc::c_void, zip_cd: u8);
}
extern "C" {
    pub fn mz_zip_writer_set_certificate(
        handle: *mut libc::c_void,
        cert_path: *const libc::c_char,
        cert_pwd: *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_set_overwrite_cb(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        cb: mz_zip_writer_overwrite_cb,
    );
}
extern "C" {
    pub fn mz_zip_writer_set_password_cb(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        cb: mz_zip_writer_password_cb,
    );
}
extern "C" {
    pub fn mz_zip_writer_set_progress_cb(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        cb: mz_zip_writer_progress_cb,
    );
}
extern "C" {
    pub fn mz_zip_writer_set_progress_interval(handle: *mut libc::c_void, milliseconds: u32);
}
extern "C" {
    pub fn mz_zip_writer_set_entry_cb(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        cb: mz_zip_writer_entry_cb,
    );
}
extern "C" {
    pub fn mz_zip_writer_get_zip_handle(
        handle: *mut libc::c_void,
        zip_handle: *mut *mut libc::c_void,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_create(handle: *mut *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    pub fn mz_zip_writer_delete(handle: *mut *mut libc::c_void);
}
